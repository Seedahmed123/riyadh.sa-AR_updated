<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>GeoAR.js Demo - Twkalna</title>
    
    <!-- A-Frame and AR.js -->
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    
    <!-- GPS Camera for A-Frame -->
    <script src="https://raw.githack.com/jeromeetienne/AR.js/master/aframe/build/aframe-ar.js"></script>
    
    <!-- Helper and Styles -->
    <script src="twkhelper/twkhelper.js"></script>
    
    <style>
      /* Reset and base styles */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        overflow: hidden;
        height: 100vh;
        background: #000;
        margin: 0;
        padding: 0;
      }

      /* AR Scene */
      a-scene {
        width: 100%;
        height: 100vh;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }

      /* Control Panel */
      #controlPanel {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 100;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 15px 25px;
        display: flex;
        gap: 15px;
        align-items: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      }

      .control-btn {
        background: linear-gradient(145deg, #00b4d8, #0077b6);
        border: none;
        color: white;
        padding: 12px 20px;
        border-radius: 12px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 100px;
        justify-content: center;
      }

      .control-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 180, 216, 0.4);
      }

      .control-btn:active {
        transform: translateY(0);
      }

      .control-btn.secondary {
        background: linear-gradient(145deg, #ff9e00, #ff5400);
      }

      /* Location List Panel */
      #locationPanel {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 300px;
        max-height: 70vh;
        background: rgba(0, 0, 0, 0.9);
        backdrop-filter: blur(20px);
        border-radius: 15px;
        padding: 15px;
        z-index: 100;
        display: none;
        flex-direction: column;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        overflow-y: auto;
      }

      .panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .panel-header h3 {
        color: white;
        font-size: 16px;
        font-weight: 600;
      }

      .close-btn {
        background: none;
        border: none;
        color: #999;
        font-size: 24px;
        cursor: pointer;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.3s ease;
      }

      .close-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        color: white;
      }

      .location-item {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        padding: 12px;
        margin-bottom: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        border: 1px solid transparent;
      }

      .location-item:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(0, 180, 216, 0.3);
      }

      .location-title {
        color: white;
        font-size: 14px;
        font-weight: 500;
        margin-bottom: 5px;
      }

      .location-distance {
        color: #00b4d8;
        font-size: 12px;
        font-weight: 500;
      }

      .location-type {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 600;
        margin-top: 5px;
      }

      .type-project {
        background: rgba(0, 180, 216, 0.2);
        color: #00b4d8;
      }

      .type-metro {
        background: rgba(255, 149, 0, 0.2);
        color: #ff9500;
      }

      /* Status Display */
      #statusDisplay {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(10px);
        color: white;
        padding: 10px 20px;
        border-radius: 12px;
        font-size: 14px;
        z-index: 100;
        display: none;
        max-width: 90%;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      /* Loader */
      #rd-loader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000;
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .loader-spinner {
        width: 50px;
        height: 50px;
        border: 3px solid rgba(255, 255, 255, 0.1);
        border-top-color: #00b4d8;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Popup */
      #popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.95);
        backdrop-filter: blur(20px);
        padding: 25px;
        border-radius: 15px;
        color: white;
        text-align: center;
        z-index: 1000;
        display: none;
        width: 90%;
        max-width: 350px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      }

      #popup h2 {
        margin-bottom: 15px;
        color: #ff4757;
        font-size: 20px;
      }

      #popup p {
        margin-bottom: 20px;
        line-height: 1.5;
        color: #ccc;
      }

      #popup button {
        background: linear-gradient(145deg, #00b4d8, #0077b6);
        border: none;
        color: white;
        padding: 10px 25px;
        border-radius: 10px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      #popup button:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 180, 216, 0.4);
      }

      /* Compass Indicator */
      #compass {
        position: fixed;
        top: 20px;
        right: 20px;
        width: 40px;
        height: 40px;
        background: rgba(0, 0, 0, 0.7);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 16px;
        z-index: 100;
        border: 2px solid rgba(255, 255, 255, 0.1);
      }

      /* RTL Support */
      [dir="rtl"] #locationPanel {
        right: auto;
        left: 20px;
      }

      [dir="rtl"] .location-item:hover {
        transform: translateX(-2px);
      }

      /* Debug info */
      #debugInfo {
        position: fixed;
        top: 70px;
        left: 20px;
        background: rgba(0, 0, 0, 0.7);
        color: #00ff00;
        padding: 8px;
        border-radius: 5px;
        font-size: 10px;
        font-family: monospace;
        z-index: 100;
        max-width: 200px;
        word-wrap: break-word;
        display: none;
      }

      /* AR Warning */
      #arWarning {
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 100, 100, 0.9);
        color: white;
        padding: 10px 20px;
        border-radius: 10px;
        font-size: 14px;
        z-index: 100;
        display: none;
        text-align: center;
        max-width: 90%;
      }
    </style>
  </head>
  <body>
    <!-- Loader -->
    <div id="rd-loader">
      <div class="loader-spinner"></div>
    </div>

    <!-- Debug Info -->
    <div id="debugInfo"></div>

    <!-- AR Warning -->
    <div id="arWarning"></div>

    <!-- AR Scene -->
    <a-scene
      vr-mode-ui="enabled: false"
      embedded
      renderer="antialias: true; alpha: true; precision: medium;"
      arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;"
    >
      <a-camera
        gps-camera="minDistance: 5; maxDistance: 1000; simulateLatitude: 0; simulateLongitude: 0;"
        look-controls-enabled
        rotation-reader
      ></a-camera>
      
      <!-- This will be our marker container -->
      <a-entity id="markerContainer"></a-entity>
    </a-scene>

    <!-- Compass Indicator -->
    <div id="compass">N</div>

    <!-- Status Display -->
    <div id="statusDisplay"></div>

    <!-- Location List Panel -->
    <div id="locationPanel">
      <div class="panel-header">
        <h3>üìç Nearby Locations</h3>
        <button class="close-btn" onclick="toggleLocationPanel()">√ó</button>
      </div>
      <div id="locationList"></div>
    </div>

    <!-- Control Panel -->
    <div id="controlPanel">
      <button class="control-btn" onclick="addMarkerAtCurrentPosition()">
        <span>üìç Add Marker</span>
      </button>
      <button class="control-btn secondary" onclick="toggleLocationPanel()">
        <span>üìã Show List</span>
      </button>
      <button class="control-btn" onclick="clearAllMarkers()">
        <span>üóëÔ∏è Clear All</span>
      </button>
    </div>

    <!-- Error Popup -->
    <div id="popup">
      <h2>Error</h2>
      <p>Message will appear here.</p>
      <button onclick="closePopup()">Close</button>
    </div>

    <script>
      // Simplified Configuration
      const CONFIG = {
        USE_MOCK_DATA: true,
        API_RADIUS: 0.02,
        MAX_DISTANCE: 1000,
        MIN_DISTANCE: 5
      };

      // State
      let currentLocation = null;
      let currentHeading = 0;
      let markers = [];
      let APP_LANG = "en";
      let allLocations = [];
      let isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

      // Translations
      const TRANSLATIONS = {
        en: {
          error: "Error",
          close: "Close",
          deviceNotSupported: "AR works only on mobile devices with camera and location services.",
          locationRequired: "Location permission is required. Please enable location services.",
          cameraRequired: "Camera permission is required for AR features.",
          noLocations: "No AR locations found nearby. Try moving to a different area.",
          addMarker: "Add Marker",
          showList: "Show List",
          clearAll: "Clear All",
          nearbyLocations: "üìç Nearby Locations",
          distance: "Distance",
          meters: "m",
          project: "Project",
          metro: "Metro Station",
          markerAdded: "Marker added at your location",
          allCleared: "All markers cleared",
          compass: "N",
          loading: "Loading AR...",
          ready: "AR Ready - Look around to see nearby locations",
          arNotSupported: "AR not supported on this device. Using fallback mode.",
          needHTTPS: "AR requires HTTPS. Loading in fallback mode."
        },
        ar: {
          error: "ÿÆÿ∑ÿ£",
          close: "ÿ•ÿ∫ŸÑÿßŸÇ",
          deviceNotSupported: "ÿßŸÑŸàÿßŸÇÿπ ÿßŸÑŸÖÿπÿ≤ÿ≤ ŸäÿπŸÖŸÑ ÿπŸÑŸâ ÿßŸÑÿ¨ŸàÿßŸÑ ŸÅŸÇÿ∑ ŸÖÿπ ÿßŸÑŸÉÿßŸÖŸäÿ±ÿß ŸàÿÆÿØŸÖÿ© ÿßŸÑŸÖŸàŸÇÿπ.",
          locationRequired: "Ÿäÿ™ÿ∑ŸÑÿ® ÿßŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿÆÿØŸÖÿ© ÿßŸÑŸÖŸàŸÇÿπ.",
          cameraRequired: "Ÿäÿ™ÿ∑ŸÑÿ® ÿßŸÑÿ≥ŸÖÿßÿ≠ ÿ®ÿßŸÑŸÉÿßŸÖŸäÿ±ÿß.",
          noLocations: "ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖŸàÿßŸÇÿπ ŸÇÿ±Ÿäÿ®ÿ© ŸÑŸÑÿπÿ±ÿ∂. ÿ¨ÿ±ÿ® ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ŸÑŸÖŸÜÿ∑ŸÇÿ© ÿ£ÿÆÿ±Ÿâ.",
          addMarker: "ÿ•ÿ∂ÿßŸÅÿ© ÿπŸÑÿßŸÖÿ©",
          showList: "ÿπÿ±ÿ∂ ÿßŸÑŸÇÿßÿ¶ŸÖÿ©",
          clearAll: "ŸÖÿ≥ÿ≠ ÿßŸÑŸÉŸÑ",
          nearbyLocations: "üìç ÿßŸÑŸÖŸàÿßŸÇÿπ ÿßŸÑŸÇÿ±Ÿäÿ®ÿ©",
          distance: "ÿßŸÑŸÖÿ≥ÿßŸÅÿ©",
          meters: "ŸÖÿ™ÿ±",
          project: "ŸÖÿ¥ÿ±Ÿàÿπ",
          metro: "ŸÖÿ≠ÿ∑ÿ© ŸÖÿ™ÿ±Ÿà",
          markerAdded: "ÿ™ŸÖÿ™ ÿ•ÿ∂ÿßŸÅÿ© ÿπŸÑÿßŸÖÿ© ŸÅŸä ŸÖŸàŸÇÿπŸÉ",
          allCleared: "ÿ™ŸÖ ŸÖÿ≥ÿ≠ ÿ¨ŸÖŸäÿπ ÿßŸÑÿπŸÑÿßŸÖÿßÿ™",
          compass: "ÿ¥",
          loading: "ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸàÿßŸÇÿπ ÿßŸÑŸÖÿπÿ≤ÿ≤...",
          ready: "ÿßŸÑŸàÿßŸÇÿπ ÿßŸÑŸÖÿπÿ≤ÿ≤ ÿ¨ÿßŸáÿ≤ - ÿßŸÜÿ∏ÿ± ÿ≠ŸàŸÑŸÉ ŸÑÿ™ÿ±Ÿâ ÿßŸÑŸÖŸàÿßŸÇÿπ ÿßŸÑŸÇÿ±Ÿäÿ®ÿ©",
          arNotSupported: "ÿßŸÑŸàÿßŸÇÿπ ÿßŸÑŸÖÿπÿ≤ÿ≤ ÿ∫Ÿäÿ± ŸÖÿØÿπŸàŸÖ ÿπŸÑŸâ Ÿáÿ∞ÿß ÿßŸÑÿ¨Ÿáÿßÿ≤. ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ ŸÅŸä Ÿàÿ∂ÿπ ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿä.",
          needHTTPS: "ÿßŸÑŸàÿßŸÇÿπ ÿßŸÑŸÖÿπÿ≤ÿ≤ Ÿäÿ™ÿ∑ŸÑÿ® HTTPS. ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ ŸÅŸä Ÿàÿ∂ÿπ ÿßÿ≠ÿ™Ÿäÿßÿ∑Ÿä."
        }
      };

      // DOM Elements
      const elements = {
        loader: document.getElementById('rd-loader'),
        popup: document.getElementById('popup'),
        locationPanel: document.getElementById('locationPanel'),
        locationList: document.getElementById('locationList'),
        controlPanel: document.getElementById('controlPanel'),
        statusDisplay: document.getElementById('statusDisplay'),
        compass: document.getElementById('compass'),
        debugInfo: document.getElementById('debugInfo'),
        arWarning: document.getElementById('arWarning'),
        scene: document.querySelector('a-scene'),
        camera: document.querySelector('a-camera'),
        markerContainer: document.getElementById('markerContainer')
      };

      // ============== UTILITY FUNCTIONS ==============
      function showLoader() {
        elements.loader.style.display = 'flex';
      }

      function hideLoader() {
        elements.loader.style.display = 'none';
      }

      function showStatus(message, duration = 3000) {
        elements.statusDisplay.textContent = message;
        elements.statusDisplay.style.display = 'block';
        setTimeout(() => {
          elements.statusDisplay.style.display = 'none';
        }, duration);
      }

      function showPopup(message) {
        elements.popup.querySelector('p').textContent = message;
        elements.popup.style.display = 'block';
      }

      function closePopup() {
        elements.popup.style.display = 'none';
      }

      function showDebugInfo(info) {
        elements.debugInfo.textContent = info;
        elements.debugInfo.style.display = 'block';
      }

      function hideDebugInfo() {
        elements.debugInfo.style.display = 'none';
      }

      function showARWarning(message) {
        elements.arWarning.textContent = message;
        elements.arWarning.style.display = 'block';
        setTimeout(() => {
          elements.arWarning.style.display = 'none';
        }, 5000);
      }

      function applyLanguage(lang) {
        APP_LANG = lang in TRANSLATIONS ? lang : "en";
        document.documentElement.lang = APP_LANG;
        document.documentElement.dir = APP_LANG === "ar" ? "rtl" : "ltr";
        
        // Update UI text
        const controlBtns = document.querySelectorAll('.control-btn');
        if (controlBtns[0]) controlBtns[0].innerHTML = `<span>üìç ${TRANSLATIONS[APP_LANG].addMarker}</span>`;
        if (controlBtns[1]) controlBtns[1].innerHTML = `<span>üìã ${TRANSLATIONS[APP_LANG].showList}</span>`;
        if (controlBtns[2]) controlBtns[2].innerHTML = `<span>üóëÔ∏è ${TRANSLATIONS[APP_LANG].clearAll}</span>`;
        
        if (elements.popup) {
          elements.popup.querySelector('h2').textContent = TRANSLATIONS[APP_LANG].error;
          elements.popup.querySelector('button').textContent = TRANSLATIONS[APP_LANG].close;
        }
        
        const panelHeader = document.querySelector('.panel-header h3');
        if (panelHeader) panelHeader.textContent = TRANSLATIONS[APP_LANG].nearbyLocations;
        
        if (elements.compass) elements.compass.textContent = TRANSLATIONS[APP_LANG].compass;
      }

      // ============== DEVICE & PERMISSIONS ==============
      async function getDeviceInfo() {
        try {
          // Check if TWK helper exists
          if (typeof TWK !== 'undefined' && TWK.getDeviceInfo) {
            const response = await TWK.getDeviceInfo();
            const info = response.result || response;
            
            // Set language from device
            if (info.app_language) {
              applyLanguage(info.app_language);
            }
            
            // Return true for mobile devices (simplified check)
            const model = (info.device_model || navigator.userAgent).toLowerCase();
            const isMobile = /iphone|ipad|ipod|android/i.test(model) || 
                            /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            
            showDebugInfo(`Device: ${model}\nMobile: ${isMobile}\niOS: ${isIOS}`);
            return isMobile;
          } else {
            // TWK not available, use browser detection
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            showDebugInfo(`TWK not available\nBrowser: ${navigator.userAgent}\nMobile: ${isMobile}`);
            return isMobile;
          }
        } catch (e) {
          console.error('Device info error:', e);
          // Fallback to browser detection
          const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
          showDebugInfo(`Error: ${e.message}\nMobile: ${isMobile}`);
          return isMobile;
        }
      }

      async function getUserLocation() {
        try {
          // Try TWK first
          if (typeof TWK !== 'undefined' && TWK.getUserLocation) {
            const response = await TWK.getUserLocation();
            const data = response.result || response;
            
            if (data.location?.latitude && data.location?.longitude) {
              currentLocation = {
                latitude: Number(data.location.latitude),
                longitude: Number(data.location.longitude)
              };
              showDebugInfo(`TWK Location: ${currentLocation.latitude}, ${currentLocation.longitude}`);
              return true;
            }
          }
          
          // Fallback to browser geolocation
          return new Promise((resolve) => {
            if (navigator.geolocation) {
              navigator.geolocation.getCurrentPosition(
                (position) => {
                  currentLocation = {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude
                  };
                  showDebugInfo(`Browser Location: ${currentLocation.latitude}, ${currentLocation.longitude}`);
                  resolve(true);
                },
                (error) => {
                  console.error('Geolocation error:', error);
                  // Use mock location for testing
                  currentLocation = {
                    latitude: 24.7136,
                    longitude: 46.6753
                  };
                  showDebugInfo(`Mock Location: ${currentLocation.latitude}, ${currentLocation.longitude}`);
                  showARWarning("Using mock location for testing");
                  resolve(true); // Still resolve true for development
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
              );
            } else {
              // Use mock location
              currentLocation = {
                latitude: 24.7136,
                longitude: 46.6753
              };
              showDebugInfo(`No geolocation, using mock: ${currentLocation.latitude}, ${currentLocation.longitude}`);
              showARWarning("Geolocation not available. Using demo location.");
              resolve(true);
            }
          });
        } catch (e) {
          console.error('Location error:', e);
          // Use mock location as fallback
          currentLocation = {
            latitude: 24.7136,
            longitude: 46.6753
          };
          showDebugInfo(`Location error, using mock: ${currentLocation.latitude}, ${currentLocation.longitude}`);
          return true;
        }
      }

      async function getCameraPermission() {
        try {
          // Try TWK first
          if (typeof TWK !== 'undefined' && TWK.askCameraPermission) {
            const response = await TWK.askCameraPermission();
            const data = response.result || response;
            return data.granted === true;
          }
          
          // For browser, we'll assume permission is granted
          // In a real app, you would request camera permission here
          return true;
        } catch (e) {
          console.error('Camera permission error:', e);
          return true; // Assume granted for development
        }
      }

      // ============== LOCATION MANAGEMENT ==============
      function getMockLocations(baseLocation) {
        const locations = [];
        const types = ['project', 'metro'];
        
        for (let i = 0; i < 8; i++) {
          const latOffset = (Math.random() - 0.5) * 0.02;
          const lonOffset = (Math.random() - 0.5) * 0.02;
          const type = types[Math.floor(Math.random() * types.length)];
          const distance = Math.floor(Math.random() * 800) + 50;
          
          locations.push({
            latitude: baseLocation.latitude + latOffset,
            longitude: baseLocation.longitude + lonOffset,
            label: APP_LANG === 'ar' 
              ? type === 'project' ? 'ŸÖÿ¥ÿ±Ÿàÿπ ÿ™ÿ¨ÿ±Ÿäÿ®Ÿä ' + (i+1) : 'ŸÖÿ≠ÿ∑ÿ© ŸÖÿ™ÿ±Ÿà ' + (i+1)
              : type === 'project' ? 'Sample Project ' + (i+1) : 'Metro Station ' + (i+1),
            distance: distance,
            type: type,
            id: 'mock-' + i
          });
        }
        
        return locations;
      }

      async function fetchLocations() {
        if (!currentLocation) return [];
        
        try {
          const url = buildApiUrl(currentLocation.latitude, currentLocation.longitude);
          console.log('Fetching from:', url);
          
          const response = await fetch(url);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          
          const data = await response.json();
          const items = data?.result?.items || [];
          
          return items
            .filter(item => item.geofield?.lat && item.geofield?.lon)
            .map(item => {
              const distance = calculateDistance(
                currentLocation.latitude,
                currentLocation.longitude,
                item.geofield.lat,
                item.geofield.lon
              );
              
              return {
                latitude: Number(item.geofield.lat),
                longitude: Number(item.geofield.lon),
                label: item.title || 'Location',
                type: item.types?.includes('metro_stations') ? 'metro' : 'project',
                distance: distance,
                id: item.id || Math.random().toString(36).substr(2, 9)
              };
            });
        } catch (error) {
          console.error('API fetch error:', error);
          return [];
        }
      }

      function buildApiUrl(lat, lon) {
        const radius = CONFIG.API_RADIUS;
        return `https://twk-services.rcrc.gov.sa/momentprojects.php?_format=json&types[]=projects&types[]=metro_stations&langcode=${APP_LANG}&lat[min]=${lat - radius}&lat[max]=${lat + radius}&lon[min]=${lon - radius}&lon[max]=${lon + radius}&on_ar=1`;
      }

      function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000;
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = 
          Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return Math.round(R * c);
      }

      // ============== AR MARKER FUNCTIONS ==============
      function createMarker(location) {
        if (!elements.markerContainer) return null;
        
        const markerId = 'marker-' + (location.id || Date.now());
        
        // Create marker entity
        const marker = document.createElement('a-entity');
        marker.setAttribute('id', markerId);
        
        // GPS position
        marker.setAttribute('gps-entity-place', {
          latitude: location.latitude,
          longitude: location.longitude
        });
        
        // Create text label
        const text = document.createElement('a-text');
        text.setAttribute('value', location.label);
        text.setAttribute('scale', '5 5 5');
        text.setAttribute('align', 'center');
        text.setAttribute('color', location.type === 'metro' ? '#FF9500' : '#00B4D8');
        text.setAttribute('look-at', '[camera]');
        text.setAttribute('position', '0 2 0');
        text.setAttribute('width', 4);
        
        // Create background for text
        const textBackground = document.createElement('a-plane');
        textBackground.setAttribute('position', '0 2 0');
        textBackground.setAttribute('width', 'auto');
        textBackground.setAttribute('height', 'auto');
        textBackground.setAttribute('scale', '1.2 1.2 1');
        textBackground.setAttribute('material', {
          color: '#000000',
          opacity: 0.7,
          transparent: true
        });
        
        // Create icon
        const icon = document.createElement('a-entity');
        const iconGeometry = location.type === 'metro' ? 'primitive: cylinder; radius: 0.3; height: 0.8' : 'primitive: box; width: 0.6; height: 0.6; depth: 0.6';
        icon.setAttribute('geometry', iconGeometry);
        icon.setAttribute('material', 'color', location.type === 'metro' ? '#FF9500' : '#00B4D8');
        icon.setAttribute('position', '0 0.5 0');
        icon.setAttribute('look-at', '[camera]');
        
        // Add distance label
        const distanceText = document.createElement('a-text');
        distanceText.setAttribute('value', `${location.distance}m`);
        distanceText.setAttribute('scale', '3 3 3');
        distanceText.setAttribute('align', 'center');
        distanceText.setAttribute('color', '#FFFFFF');
        distanceText.setAttribute('position', '0 3 0');
        distanceText.setAttribute('look-at', '[camera]');
        
        // Add click event
        marker.addEventListener('click', () => {
          showStatus(`${location.label}\n${TRANSLATIONS[APP_LANG].distance}: ${location.distance}m`);
        });
        
        // Assemble marker
        marker.appendChild(textBackground);
        marker.appendChild(text);
        marker.appendChild(icon);
        marker.appendChild(distanceText);
        
        elements.markerContainer.appendChild(marker);
        markers.push({ element: marker, location: location });
        
        console.log(`Marker created at: ${location.latitude}, ${location.longitude}`);
        return marker;
      }

      function addMarkerAtCurrentPosition() {
        if (!currentLocation) {
          showPopup(TRANSLATIONS[APP_LANG].locationRequired);
          return;
        }
        
        const markerLocation = {
          ...currentLocation,
          label: APP_LANG === 'ar' ? 'ÿπŸÑÿßŸÖÿ™Ÿä' : 'My Marker',
          type: 'project',
          distance: 0,
          id: 'user-marker-' + Date.now()
        };
        
        createMarker(markerLocation);
        showStatus(TRANSLATIONS[APP_LANG].markerAdded);
      }

      function clearAllMarkers() {
        markers.forEach(marker => {
          if (marker.element && marker.element.parentNode) {
            marker.element.parentNode.removeChild(marker.element);
          }
        });
        markers = [];
        showStatus(TRANSLATIONS[APP_LANG].allCleared);
      }

      function toggleLocationPanel() {
        const panel = elements.locationPanel;
        panel.style.display = panel.style.display === 'flex' ? 'none' : 'flex';
        
        if (panel.style.display === 'flex') {
          updateLocationList();
        }
      }

      function updateLocationList() {
        const list = elements.locationList;
        if (!list) return;
        
        list.innerHTML = '';
        
        if (allLocations.length === 0) {
          list.innerHTML = `<div style="color: #999; text-align: center; padding: 20px;">
            ${TRANSLATIONS[APP_LANG].noLocations}
          </div>`;
          return;
        }
        
        // Sort by distance
        const sortedLocations = [...allLocations].sort((a, b) => a.distance - b.distance);
        
        sortedLocations.forEach((location) => {
          const item = document.createElement('div');
          item.className = 'location-item';
          item.innerHTML = `
            <div class="location-title">${location.label}</div>
            <div class="location-distance">
              ${TRANSLATIONS[APP_LANG].distance}: ${location.distance || 0}${TRANSLATIONS[APP_LANG].meters}
            </div>
            <div class="location-type type-${location.type}">
              ${TRANSLATIONS[APP_LANG][location.type]}
            </div>
          `;
          
          item.addEventListener('click', () => {
            createMarker(location);
            toggleLocationPanel();
            showStatus(`${location.label} - ${location.distance || 0}m`);
          });
          
          list.appendChild(item);
        });
      }

      function updateCompass(heading) {
        currentHeading = heading;
        const compass = elements.compass;
        if (!compass) return;
        
        const directions = APP_LANG === 'ar' 
          ? ['ÿ¥', 'ÿ¥ÿ±', 'ÿ¨', 'ÿ∫'] 
          : ['N', 'E', 'S', 'W'];
        
        const directionIndex = Math.round((heading % 360) / 90) % 4;
        compass.textContent = directions[directionIndex];
        compass.style.transform = `rotate(${-heading}deg)`;
      }

      // ============== INITIALIZATION ==============
      async function initAR() {
        showLoader();
        showStatus(TRANSLATIONS[APP_LANG].loading);
        
        try {
          // Check if we're on HTTPS (required for camera on iOS)
          if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {
            showARWarning(TRANSLATIONS[APP_LANG].needHTTPS);
          }
          
          // Check device (simplified - always return true for iOS)
          const isMobileDevice = await getDeviceInfo();
          if (!isMobileDevice && !isIOS) {
            throw new Error(TRANSLATIONS[APP_LANG].deviceNotSupported);
          }
          
          // Get location (with fallback)
          const hasLocation = await getUserLocation();
          if (!hasLocation) {
            throw new Error(TRANSLATIONS[APP_LANG].locationRequired);
          }
          
          // Get camera permission
          const hasCamera = await getCameraPermission();
          if (!hasCamera) {
            throw new Error(TRANSLATIONS[APP_LANG].cameraRequired);
          }
          
          // Fetch locations
          let locations = await fetchLocations();
          
          // Use mock data if no locations found or for testing
          if (CONFIG.USE_MOCK_DATA && locations.length === 0) {
            console.log('Using mock locations for testing');
            locations = getMockLocations(currentLocation);
          }
          
          if (locations.length === 0) {
            throw new Error(TRANSLATIONS[APP_LANG].noLocations);
          }
          
          allLocations = locations;
          
          // Wait for A-Frame scene to load
          elements.scene.addEventListener('loaded', () => {
            console.log('A-Frame scene loaded');
            
            // Add initial markers (first 5)
            const initialMarkers = locations.slice(0, 5);
            initialMarkers.forEach(location => {
              createMarker(location);
            });
            
            // Set up compass updates
            if (elements.camera) {
              elements.camera.addEventListener('rotation-reader', (event) => {
                if (event.detail && event.detail.rotation) {
                  updateCompass(event.detail.rotation.alpha || 0);
                }
              });
            }
            
            hideLoader();
            showStatus(TRANSLATIONS[APP_LANG].ready, 4000);
            
            // Hide debug info after 10 seconds
            setTimeout(hideDebugInfo, 10000);
          });
          
        } catch (error) {
          console.error('Initialization error:', error);
          hideLoader();
          showPopup(error.message || 'Unknown error occurred');
        }
      }

      // ============== EVENT LISTENERS ==============
      window.addEventListener('DOMContentLoaded', () => {
        // Start initialization after a short delay
        setTimeout(initAR, 500);
      });
      
      // Handle screen tap for adding markers
      if (elements.scene) {
        elements.scene.addEventListener('click', (event) => {
          console.log('AR scene clicked', event.detail);
        });
      }
      
      // Handle orientation changes
      window.addEventListener('deviceorientation', (event) => {
        if (event.alpha !== null) {
          updateCompass(event.alpha);
        }
      });
      
      // Handle visibility changes
      document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
          // Refresh locations when app becomes visible again
          setTimeout(updateLocationList, 1000);
        }
      });

      // ============== GLOBAL FUNCTIONS ==============
      window.toggleLocationPanel = toggleLocationPanel;
      window.addMarkerAtCurrentPosition = addMarkerAtCurrentPosition;
      window.clearAllMarkers = clearAllMarkers;
      window.closePopup = closePopup;
    </script>
  </body>
</html>